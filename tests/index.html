<!DOCTYPE html>
<html>
<head>
    <title>socket.io-rpc test vanilla client</title>
</head>
<body>
<h1>Plain browser socket.io-rpc test/showcase</h1>
getTime: <span id="serverTime"></span><br>
asyncTest: <span id="asyncText"></span>

<script src="/socket.io/socket.io.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/q.js/1.0.1/q.js"></script>
<script type="text/javascript">
	if (!window.Promise || !window.Promise.defer) {
		Promise = Q;
	}
</script>
<script src="/rpc/rpc-client.js"></script>
<script>
    var backend = RPC('http://localhost:8081');
    backend.loadChannel('myChannel', {passw: '123'})
            .then(function (channel) {
                channel.getTime().then(function (date) {
                    console.log('time on server is: ' + date);
					setText(document.getElementById('serverTime'), date);

				});
                channel.myAsyncTest('passing string as argument').then(function (retVal) {
                    console.log('server returned: ' + retVal);
					setText(document.getElementById('asyncText'), retVal);
                }, function (er) {
                    console.error('error callback called');
                });
                channel.failingMethod();    // this will display error prpagated from serverside
                channel._socket.on('disconnect', function () {
                    console.log("channel disconnected!");
                });


                //channel.nonExistentRemoteFn();  // uncomment for typerror to be thrown and handled by otherwise promise method
            }, function (err) {
				console.log(err + ' equals TypeError: Object #<Object> has no method nonExistentRemoteFn');
			});
	
    backend.expose('clientChannel', {
        fnOnClient: function (param) {
            return 'whatever you need from client returned ' + param;
        }
    }).then(function (channel) {
                console.log(" client channel ready");
            }, function (err) {
                debugger;
            }
    );

	function setText(elem, changeVal) {
		if ((elem.textContent) && (typeof (elem.textContent) != "undefined")) {
			elem.textContent = changeVal;
		} else {
			elem.innerText = changeVal;
		}
	}
</script>
</body>

</html>